<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KVK Zoeken + OpenLayers Plot (Test)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size: 18px; margin: 0 8px 0 0; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    label { font-size: 12px; color:#555; }
    input, select, button { padding:8px 10px; border:1px solid #ccc; border-radius:8px; font-size:14px; }
    button { cursor:pointer; }
    main { display:grid; grid-template-columns: 380px 1fr; gap:0; height: calc(100vh - 58px); }
    #sidebar { border-right:1px solid #eee; overflow:auto; }
    #map { width:100%; height:100%; }
    .section { padding: 12px 14px; }
    .result { border:1px solid #eee; border-radius:10px; padding:10px; margin:8px 0; }
    .result h3 { margin:0; font-size:16px; }
    .muted { color:#666; font-size:12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .stack { display:flex; flex-direction:column; gap:6px; }
    .error { color:#b00020; background:#fff2f2; border:1px solid #ffd7d7; padding:8px 10px; border-radius:8px; white-space:pre-wrap; }
    .badge { display:inline-block; background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 8px; border-radius:999px; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <h1>KVK Basisprofiel ↔ Naamzoek → Plot op kaart</h1>
    <div class="controls">
      <label>API-base
        <select id="apiBase">
          <option value="https://developers.kvk.nl/test">developers.kvk.nl/test</option>
          <option value="https://api.kvk.nl/test">api.kvk.nl/test</option>
        </select>
      </label>
      <label style="min-width:280px;">API key
        <input id="apiKey" value="l7xx1f2691f2520d487b902f4e0b57a0b197" />
      </label>
      <label class="row" title="Gebruik KVK geoData voor coordinaten (zo beschikbaar)">
        <input type="checkbox" id="useGeoData" /> geoData gebruiken
      </label>
      <label>KVK-nummer of naam
        <input id="kvkInput" placeholder="bv. 69599068 of 'Global Conron'" />
      </label>
      <button id="btnGet">Zoek / haal op</button>
      <span id="status" class="muted"></span>
    </div>
  </header>

  <main>
    <aside id="sidebar">
      <div class="section">
        <div id="summary" class="muted">Vul een KVK-nummer (8 cijfers) of (deel van) een naam in en klik “Zoek / haal op”. Klik daarna “Plot op kaart”.</div>
        <div id="results"></div>
      </div>
    </aside>
    <section id="map"></section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // --- OpenLayers kaart ---
    const map = new ol.Map({
      target: 'map',
      layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ],
      view: new ol.View({ center: ol.proj.fromLonLat([5.387, 52.156]), zoom: 7 })
    });

    const vectorSource = new ol.source.Vector();
    const vectorLayer = new ol.layer.Vector({ source: vectorSource });
    map.addLayer(vectorLayer);

    function addMarker(lon, lat, label) {
      const feature = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
        name: label
      });
      feature.setStyle(new ol.style.Style({
        image: new ol.style.Circle({
          radius: 6,
          fill: new ol.style.Fill({ color: '#2563eb' }),
          stroke: new ol.style.Stroke({ color: '#1e40af', width: 2 })
        }),
        text: new ol.style.Text({
          text: label || '',
          offsetY: -14,
          font: '12px sans-serif',
          fill: new ol.style.Fill({ color: '#111' }),
          stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
        })
      }));
      vectorSource.addFeature(feature);
      return feature;
    }

    function fitToFeatures() {
      const extent = vectorSource.getExtent();
      if (extent && extent.every(isFinite)) {
        map.getView().fit(extent, { padding: [30, 30, 30, 30], maxZoom: 16, duration: 400 });
      }
    }

    // --- Generic: robuuste fetch met fallback proxies en retries ---
    async function fetchJSONWithProxy(targetUrl, { retries = 2, timeoutMs = 12000 } = {}) {
      const candidates = [
        { kind: 'direct', build: (u) => ({ url: u, isAllOrigins: false }) },
        { kind: 'corsproxy.io', build: (u) => ({ url: `https://corsproxy.io/?${encodeURIComponent(u)}`, isAllOrigins: false }) },
        { kind: 'isomorphic', build: (u) => ({ url: `https://cors.isomorphic-git.org/${u}`, isAllOrigins: false }) },
        { kind: 'allorigins', build: (u) => ({ url: `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`, isAllOrigins: true }) },
      ];
      let lastErr;
      for (let attempt = 0; attempt <= retries; attempt++) {
        for (const p of candidates) {
          try {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            const cfg = p.build(targetUrl);
            const res = await fetch(cfg.url, { signal: controller.signal });
            clearTimeout(id);
            if (!res.ok) throw new Error(`${p.kind} proxy HTTP ${res.status}`);
            const data = cfg.isAllOrigins ? JSON.parse((await res.json()).contents) : await res.json();
            return data;
          } catch (e) {
            lastErr = e; // probeer volgende proxy
          }
        }
        await new Promise(r => setTimeout(r, 300 + attempt * 300)); // backoff en opnieuw
      }
      throw lastErr || new Error('Proxy chain failed');
    }

    // --- KVK API helpers ---
    async function kvkBasisprofiel({ base, apikey, kvkNummer, geoData=false }) {
      const url = new URL(`${base}/api/v1/basisprofielen/${encodeURIComponent(kvkNummer)}`);
      url.searchParams.set('geoData', String(geoData));
      // NB: In productie hoort de apikey als header via een eigen server/proxy.
      return await fetchJSONWithProxy(url.toString(), { retries: 2, timeoutMs: 12000 });
    }

    async function kvkZoekOpNaam({ base, apikey, naam, pagina = 1, resultatenPerPagina = 10 }) {
      const url = new URL(`${base}/api/v2/zoeken`);
      url.searchParams.set('naam', naam);
      url.searchParams.set('pagina', String(pagina));
      url.searchParams.set('resultatenPerPagina', String(resultatenPerPagina));
      return await fetchJSONWithProxy(url.toString(), { retries: 2, timeoutMs: 12000 });
    }

    // --- PDOK geocoder (v3.1) ---
    async function geocodePDOK(addressString) {
      const url = new URL('https://api.pdok.nl/bzk/locatieserver/search/v3_1/free');
      url.searchParams.set('q', addressString);
      url.searchParams.set('fq', 'type:adres');
      url.searchParams.set('fl', 'centroide_ll,centroide_rd,weergavenaam,score');
      url.searchParams.set('rows', '1');

      const res = await fetch(url.toString());
      if (!res.ok) throw new Error(`Geocoding faalde: ${res.status} ${res.statusText}`);

      const data = await res.json();
      const doc = data?.response?.docs?.[0];
      if (!doc || !doc.centroide_ll) throw new Error('Geen coördinaten gevonden voor: ' + addressString);

      const match = doc.centroide_ll.match(/POINT\(([-0-9.]+) ([0-9.]+)\)/);
      if (!match) throw new Error(`Kon POINT niet parsen uit: ${doc.centroide_ll}`);

      return { lon: parseFloat(match[1]), lat: parseFloat(match[2]), doc };
    }

    // --- Basisprofiel helpers ---
    function extractLatLonFromObject(obj) {
      let lat = null, lon = null;
      function visit(o) {
        if (!o || typeof o !== 'object') return;
        for (const [k, v] of Object.entries(o)) {
          const key = k.toLowerCase();
          if (typeof v === 'number') {
            if ((key === 'lat' || key === 'latitude' || key === 'breedte' || key === 'breedtegraad') && lat === null) lat = v;
            if ((key === 'lon' || key === 'lng' || key === 'long' || key === 'longitude' || key === 'lengte' || key === 'lengtegraad') && lon === null) lon = v;
          } else if (typeof v === 'string') {
            const num = Number(v);
            if (!Number.isNaN(num)) {
              if ((key === 'lat' || key === 'latitude') && lat === null) lat = num;
              if ((key === 'lon' || key === 'lng' || key === 'long' || key === 'longitude') && lon === null) lon = num;
            }
          } else if (typeof v === 'object') {
            visit(v);
          }
        }
      }
      visit(obj);
      return (lat != null && lon != null) ? { lat, lon } : null;
    }

    function findLatLonInBasisprofiel(bp) {
      const candidates = [];
      if (bp.geoData) candidates.push(bp.geoData);
      if (bp.hoofdvestiging) {
        if (bp.hoofdvestiging.geoData) candidates.push(bp.hoofdvestiging.geoData);
        if (Array.isArray(bp.hoofdvestiging.adressen)) {
          bp.hoofdvestiging.adressen.forEach(a => { if (a.geoData) candidates.push(a.geoData); });
        }
        if (bp.hoofdvestiging.bezoekadres?.geoData) candidates.push(bp.hoofdvestiging.bezoekadres.geoData);
      }
      if (bp.eigenaar) {
        if (Array.isArray(bp.eigenaar.adressen)) {
          bp.eigenaar.adressen.forEach(a => { if (a.geoData) candidates.push(a.geoData); });
        }
      }
      for (const c of candidates) {
        const ll = extractLatLonFromObject(c);
        if (ll) return ll;
      }
      return null;
    }

    function addressFromBasisprofiel(bp) {
      const eig = bp._embedded?.eigenaar;
      const hv = bp.hoofdvestiging;
      const cand = [];
      if (eig?.adressen && Array.isArray(eig.adressen)) cand.push(...eig.adressen);
      if (hv?.bezoekadres) cand.push(hv.bezoekadres);
      if (hv?.postadres) cand.push(hv.postadres);

      function fmt(a) {
        if (!a) return null;
        if (a.volledigAdres) return a.volledigAdres.trim();
        const parts = [];
        if (a.straatnaam) parts.push(a.straatnaam);
        if (a.huisnummer) parts.push(String(a.huisnummer) + (a.huisletter || ''));
        if (a.huisnummertoevoeging) parts.push(a.huisnummertoevoeging);
        const street = parts.join(' ');
        const city = [a.postcode, a.plaats].filter(Boolean).join(' ');
        return [street, city].filter(Boolean).join(', ');
      }

      for (const a of cand) {
        const s = fmt(a);
        if (s) return s;
      }
      return null;
    }

    // --- UI refs ---
    const apiBaseEl = document.getElementById('apiBase');
    const apiKeyEl = document.getElementById('apiKey');
    const useGeoDataEl = document.getElementById('useGeoData');
    const kvkInputEl = document.getElementById('kvkInput');
    const btnGet = document.getElementById('btnGet');
    const resultsEl = document.getElementById('results');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');

    function showStatus(text) { statusEl.textContent = text || ''; }
    function showError(msg) {
      statusEl.textContent = '';
      const div = document.createElement('div');
      div.className = 'error section';
      div.textContent = msg;
      resultsEl.prepend(div);
    }

    // --- Rendering ---
    function renderBasisprofiel(bp, { base, apikey, usedGeo }) {
      resultsEl.innerHTML = '';
      const card = document.createElement('div');
      card.className = 'result stack';

      const title = document.createElement('h3');
      title.textContent = `${bp.naam || bp.statutaireNaam || '(naam onbekend)'} — ${bp.kvkNummer || ''}`;
      card.appendChild(title);

      const sbiWrap = document.createElement('div');
      const sbi = Array.isArray(bp.sbiActiviteiten) ? bp.sbiActiviteiten : [];
      if (sbi.length) {
        sbiWrap.innerHTML = sbi.map(x => {
          const hoofd = (x.indHoofdactiviteit || '').toLowerCase() === 'ja' ? ' (hoofd)' : '';
          return `<span class="badge">SBI ${x.sbiCode}${hoofd}</span> <span class="muted">${x.sbiOmschrijving || ''}</span>`;
        }).join('<br/>');
      } else {
        sbiWrap.innerHTML = '<span class="muted">Geen SBI-activiteiten gevonden</span>';
      }
      card.appendChild(sbiWrap);

      const meta = document.createElement('div');
      meta.className = 'muted';
      const rechtsvorm = bp._embedded?.eigenaar?.uitgebreideRechtsvorm || bp._embedded?.eigenaar?.rechtsvorm || '';
      meta.textContent = `${rechtsvorm}`;
      card.appendChild(meta);

      const addr = addressFromBasisprofiel(bp);
      if (addr) {
        const addrDiv = document.createElement('div');
        addrDiv.className = 'muted';
        addrDiv.innerHTML = `<span class="badge">adres:</span> ${addr}`;
        card.appendChild(addrDiv);
      }

      const row = document.createElement('div');
      row.className = 'row';

      const btnPlot = document.createElement('button');
      btnPlot.textContent = 'Plot op kaart';
      btnPlot.addEventListener('click', async () => {
        try {
          btnPlot.disabled = true; btnPlot.textContent = 'Bezig…';
          let lon, lat;
          if (usedGeo) {
            const ll = findLatLonInBasisprofiel(bp);
            if (ll) { lon = ll.lon; lat = ll.lat; }
          }
          if (lon == null || lat == null) {
            const address = addr || addressFromBasisprofiel(bp);
            if (!address) throw new Error('Geen (geoData of) adres gevonden in basisprofiel.');
            const g = await geocodePDOK(address);
            lon = g.lon; lat = g.lat;
          }
          addMarker(lon, lat, bp.naam || bp.kvkNummer);
          fitToFeatures();
          btnPlot.textContent = 'Geplot ✓';
        } catch (e) {
          showError(e.message);
          btnPlot.textContent = 'Plot op kaart';
        } finally {
          btnPlot.disabled = false;
        }
      });
      row.appendChild(btnPlot);

      const selfLink = (bp.links || []).find(l => (l.rel || '').toLowerCase() === 'self');
      if (selfLink) {
        const a = document.createElement('a');
        a.href = selfLink.href; a.target = '_blank'; a.rel = 'noreferrer noopener';
        a.textContent = 'Basisprofiel (JSON)';
        row.appendChild(a);
      }

      card.appendChild(row);
      resultsEl.appendChild(card);
      summaryEl.textContent = `Basisprofiel geladen (${bp.kvkNummer})`;
    }

    function renderZoekResultaten(zoek, { base, apikey }) {
      resultsEl.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'section';

      const hdr = document.createElement('div');
      hdr.className = 'muted';
      hdr.textContent = `Zoekresultaten: ${zoek.totaal} gevonden`;
      wrap.appendChild(hdr);

      if (!Array.isArray(zoek.resultaten) || zoek.resultaten.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'muted';
        empty.textContent = 'Geen resultaten.';
        wrap.appendChild(empty);
      } else {
        zoek.resultaten.forEach(item => {
          const card = document.createElement('div');
          card.className = 'result stack';

          const title = document.createElement('h3');
          title.textContent = `${item.naam || '(naam onbekend)'} — ${item.kvkNummer || ''}`;
          card.appendChild(title);

          const ad = item.adres?.binnenlandsAdres;
          if (ad) {
            const addrLine = [ad.straatnaam, ad.huisnummer, ad.huisletter, ad.postcode, ad.plaats]
              .filter(Boolean).join(' ').replace(/\s+/g,' ');
            const addrDiv = document.createElement('div');
            addrDiv.className = 'muted';
            addrDiv.innerHTML = `<span class="badge">adres:</span> ${addrLine}`;
            card.appendChild(addrDiv);
          }

          const row = document.createElement('div');
          row.className = 'row';

          const btn = document.createElement('button');
          btn.textContent = 'Laad basisprofiel';
          btn.addEventListener('click', async () => {
            try {
              btn.disabled = true; btn.textContent = 'Bezig…';
              const bp = await kvkBasisprofiel({
                base,
                apikey,
                kvkNummer: item.kvkNummer,
                geoData: !!useGeoDataEl.checked
              });
              renderBasisprofiel(bp, { base, apikey, usedGeo: !!useGeoDataEl.checked });
            } catch (e) {
              const d = e.details;
              if (d) {
                showError(`Basisprofiel fout (${d.status} ${d.statusText})
URL: ${d.url}
Body: ${d.body?.slice(0,500) || '(leeg)'}`);
              } else {
                showError(e.message || 'Onbekende fout');
              }
            } finally {
              btn.disabled = false; btn.textContent = 'Laad basisprofiel';
            }
          });
          row.appendChild(btn);

          const basisLink = (item.links || []).find(l => (l.rel || '').toLowerCase() === 'basisprofiel');
          if (basisLink) {
            const a = document.createElement('a');
            a.href = basisLink.href; a.target = '_blank'; a.rel = 'noreferrer noopener';
            a.textContent = 'Basisprofiel (JSON)';
            row.appendChild(a);
          }

          card.appendChild(row);
          wrap.appendChild(card);
        });
      }

      resultsEl.appendChild(wrap);
    }

    // --- Event: zoeken / ophalen ---
    const btnHandler = async () => {
      vectorSource.clear();
      resultsEl.innerHTML = '';
      const base = apiBaseEl.value;
      const apikey = apiKeyEl.value.trim();
      const query = kvkInputEl.value.trim();
      const useGeo = !!useGeoDataEl.checked;
      if (!query) { showError('Vul een KVK-nummer of (deel van) een naam in.'); return; }

      try {
        showStatus('Bezig…');

        if (/^\d{8}$/.test(query)) {
          // KVK-nummer → direct basisprofiel
          const bp = await kvkBasisprofiel({ base, apikey, kvkNummer: query, geoData: useGeo });
          renderBasisprofiel(bp, { base, apikey, usedGeo: useGeo });
          summaryEl.textContent = `Basisprofiel geladen (${bp.kvkNummer})`;
        } else {
          // Naam → zoeken en lijst tonen
          const zoek = await kvkZoekOpNaam({ base, apikey, naam: query, pagina: 1, resultatenPerPagina: 10 });
          renderZoekResultaten(zoek, { base, apikey });
          summaryEl.textContent = `Zoekopdracht uitgevoerd: “${query}”`;
        }

        showStatus('');
      } catch (e) {
        const d = e.details;
        if (d) {
          showError(`Fout (${d.status} ${d.statusText})
URL: ${d.url}
Body: ${d.body?.slice(0,500) || '(leeg)'}
Tip: controleer API key / test endpoint / invoer.`);
        } else {
          showError(e.message || 'Onbekende fout');
        }
        showStatus('');
      }
    };

    btnGet.addEventListener('click', btnHandler);
    kvkInputEl.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') btnHandler(); });

    // Demo: prefill
    kvkInputEl.value = '69599068';
  </script>
</body>
</html>
