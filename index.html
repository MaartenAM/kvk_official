<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KVK Zoeken + Auto-plot (Test)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@latest/ol.css" />
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    header { padding: 12px 16px; border-bottom: 1px solid #eee; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size: 18px; margin: 0 8px 0 0; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    label { font-size: 12px; color:#555; }
    input, select, button { padding:8px 10px; border:1px solid #ccc; border-radius:8px; font-size:14px; }
    button { cursor:pointer; }
    main { display:grid; grid-template-columns: 420px 1fr; gap:0; height: calc(100vh - 58px); }
    #sidebar { border-right:1px solid #eee; overflow:auto; }
    #map { width:100%; height:100%; }
    .section { padding: 12px 14px; }
    .result { border:1px solid #eee; border-radius:10px; padding:10px; margin:8px 0; }
    .result h3 { margin:0; font-size:16px; }
    .muted { color:#666; font-size:12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .stack { display:flex; flex-direction:column; gap:6px; }
    .error { color:#b00020; background:#fff2f2; border:1px solid #ffd7d7; padding:8px 10px; border-radius:8px; white-space:pre-wrap; }
    .badge { display:inline-block; background:#f3f4f6; border:1px solid #e5e7eb; padding:2px 8px; border-radius:999px; font-size:12px; }
    .chip  { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #e5e7eb; background:#f9fafb; }
    .ok { color:#065f46; border-color:#d1fae5; background:#ecfdf5; }
    .warn { color:#7c2d12; border-color:#fed7aa; background:#fffbeb; }
    .info { color:#1e40af; border-color:#bfdbfe; background:#eff6ff; }
  </style>
</head>
<body>
  <header>
    <h1>KVK Basisprofiel ↔ Naamzoek → Auto-plot</h1>
    <div class="controls">
      <label>API-base
        <select id="apiBase">
          <option value="https://developers.kvk.nl/test">developers.kvk.nl/test</option>
          <option value="https://api.kvk.nl/test">api.kvk.nl/test</option>
        </select>
      </label>
      <label style="min-width:280px;">API key
        <input id="apiKey" value="l7xx1f2691f2520d487b902f4e0b57a0b197" />
      </label>
      <label class="row" title="Gebruik KVK geoData voor coordinaten (zo beschikbaar)">
        <input type="checkbox" id="useGeoData" /> geoData gebruiken
      </label>
      <label>KVK-nummer of naam
        <input id="kvkInput" placeholder="bv. 69599068 of 'Global Conron'" />
      </label>
      <button id="btnGet">Zoek / haal op</button>
      <span id="status" class="muted"></span>
    </div>
  </header>

  <main>
    <aside id="sidebar">
      <div class="section">
        <div id="summary" class="muted">Vul een KVK-nummer (8 cijfers) of (deel van) een naam in en klik “Zoek / haal op”. Bij naam: basisprofielen worden automatisch opgehaald en geplot.</div>
        <div id="results"></div>
      </div>
    </aside>
    <section id="map"></section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/ol@latest/dist/ol.js"></script>
  <script>
    // --- OpenLayers kaart ---
    const map = new ol.Map({
      target: 'map',
      layers: [ new ol.layer.Tile({ source: new ol.source.OSM() }) ],
      view: new ol.View({ center: ol.proj.fromLonLat([5.387, 52.156]), zoom: 7 })
    });

    const vectorSource = new ol.source.Vector();
    const vectorLayer = new ol.layer.Vector({ source: vectorSource });
    map.addLayer(vectorLayer);

    function addMarker(lon, lat, label) {
      const feature = new ol.Feature({
        geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat])),
        name: label
      });
      feature.setStyle(new ol.style.Style({
        image: new ol.style.Circle({
          radius: 6,
          fill: new ol.style.Fill({ color: '#2563eb' }),
          stroke: new ol.style.Stroke({ color: '#1e40af', width: 2 })
        }),
        text: new ol.style.Text({
          text: label || '',
          offsetY: -14,
          font: '12px sans-serif',
          fill: new ol.style.Fill({ color: '#111' }),
          stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
        })
      }));
      vectorSource.addFeature(feature);
      return feature;
    }

    function fitToFeatures() {
      const extent = vectorSource.getExtent();
      if (extent && extent.every(isFinite)) {
        map.getView().fit(extent, { padding: [30, 30, 30, 30], maxZoom: 16, duration: 400 });
      }
    }

    // --- Robuuste fetch met fallback proxies + retries ---
    async function fetchJSONWithProxy(targetUrl, { retries = 2, timeoutMs = 12000 } = {}) {
      const candidates = [
        { kind: 'direct', build: (u) => ({ url: u, isAllOrigins: false }) },
        { kind: 'corsproxy.io', build: (u) => ({ url: `https://corsproxy.io/?${encodeURIComponent(u)}`, isAllOrigins: false }) },
        { kind: 'isomorphic', build: (u) => ({ url: `https://cors.isomorphic-git.org/${u}`, isAllOrigins: false }) },
        { kind: 'allorigins', build: (u) => ({ url: `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`, isAllOrigins: true }) },
      ];
      let lastErr;
      for (let attempt = 0; attempt <= retries; attempt++) {
        for (const p of candidates) {
          try {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            const cfg = p.build(targetUrl);
            const res = await fetch(cfg.url, { signal: controller.signal });
            clearTimeout(id);
            if (!res.ok) throw new Error(`${p.kind} proxy HTTP ${res.status}`);
            const data = cfg.isAllOrigins ? JSON.parse((await res.json()).contents) : await res.json();
            return data;
          } catch (e) {
            lastErr = e; // volgende proxy proberen
          }
        }
        await new Promise(r => setTimeout(r, 300 + attempt * 300)); // backoff
      }
      throw lastErr || new Error('Proxy chain failed');
    }

    // --- KVK API helpers ---
    async function kvkBasisprofiel({ base, apikey, kvkNummer, geoData=false }) {
      const url = new URL(`${base}/api/v1/basisprofielen/${encodeURIComponent(kvkNummer)}`);
      url.searchParams.set('geoData', String(geoData));
      return await fetchJSONWithProxy(url.toString(), { retries: 2, timeoutMs: 12000 });
    }

    async function kvkZoekOpNaam({ base, apikey, naam, pagina = 1, resultatenPerPagina = 10 }) {
      const url = new URL(`${base}/api/v2/zoeken`);
      url.searchParams.set('naam', naam);
      url.searchParams.set('pagina', String(pagina));
      url.searchParams.set('resultatenPerPagina', String(resultatenPerPagina));
      return await fetchJSONWithProxy(url.toString(), { retries: 2, timeoutMs: 12000 });
    }

    // --- PDOK geocoder (v3.1) ---
    async function geocodePDOK(addressString) {
      const url = new URL('https://api.pdok.nl/bzk/locatieserver/search/v3_1/free');
      url.searchParams.set('q', addressString);
      url.searchParams.set('fq', 'type:adres');
      url.searchParams.set('fl', 'centroide_ll,centroide_rd,weergavenaam,score');
      url.searchParams.set('rows', '1');

      const res = await fetch(url.toString());
      if (!res.ok) throw new Error(`Geocoding faalde: ${res.status} ${res.statusText}`);

      const data = await res.json();
      const doc = data?.response?.docs?.[0];
      if (!doc || !doc.centroide_ll) throw new Error('Geen coördinaten gevonden voor: ' + addressString);

      const match = doc.centroide_ll.match(/POINT\(([-0-9.]+) ([0-9.]+)\)/);
      if (!match) throw new Error(`Kon POINT niet parsen uit: ${doc.centroide_ll}`);

      return { lon: parseFloat(match[1]), lat: parseFloat(match[2]), doc };
    }

    // --- Basisprofiel helpers ---
    function extractLatLonFromObject(obj) {
      let lat = null, lon = null;
      function visit(o) {
        if (!o || typeof o !== 'object') return;
        for (const [k, v] of Object.entries(o)) {
          const key = k.toLowerCase();
          if (typeof v === 'number') {
            if ((key === 'lat' || key === 'latitude' || key === 'breedte' || key === 'breedtegraad') && lat === null) lat = v;
            if ((key === 'lon' || key === 'lng' || key === 'long' || key === 'longitude' || key === 'lengte' || key === 'lengtegraad') && lon === null) lon = v;
          } else if (typeof v === 'string') {
            const num = Number(v);
            if (!Number.isNaN(num)) {
              if ((key === 'lat' || key === 'latitude') && lat === null) lat = num;
              if ((key === 'lon' || key === 'lng' || key === 'long' || key === 'longitude') && lon === null) lon = num;
            }
          } else if (typeof v === 'object') {
            visit(v);
          }
        }
      }
      visit(obj);
      return (lat != null && lon != null) ? { lat, lon } : null;
    }

    function findLatLonInBasisprofiel(bp) {
      const candidates = [];
      if (bp.geoData) candidates.push(bp.geoData);
      if (bp.hoofdvestiging) {
        if (bp.hoofdvestiging.geoData) candidates.push(bp.hoofdvestiging.geoData);
        if (Array.isArray(bp.hoofdvestiging.adressen)) {
          bp.hoofdvestiging.adressen.forEach(a => { if (a.geoData) candidates.push(a.geoData); });
        }
        if (bp.hoofdvestiging.bezoekadres?.geoData) candidates.push(bp.hoofdvestiging.bezoekadres.geoData);
      }
      if (bp.eigenaar) {
        if (Array.isArray(bp.eigenaar.adressen)) {
          bp.eigenaar.adressen.forEach(a => { if (a.geoData) candidates.push(a.geoData); });
        }
      }
      for (const c of candidates) {
        const ll = extractLatLonFromObject(c);
        if (ll) return ll;
      }
      return null;
    }

    function addressFromBasisprofiel(bp) {
      const eig = bp._embedded?.eigenaar;
      const hv = bp.hoofdvestiging;
      const cand = [];
      if (eig?.adressen && Array.isArray(eig.adressen)) cand.push(...eig.adressen);
      if (hv?.bezoekadres) cand.push(hv.bezoekadres);
      if (hv?.postadres) cand.push(hv.postadres);

      function fmt(a) {
        if (!a) return null;
        if (a.volledigAdres) return a.volledigAdres.trim();
        const parts = [];
        if (a.straatnaam) parts.push(a.straatnaam);
        if (a.huisnummer) parts.push(String(a.huisnummer) + (a.huisletter || ''));   <!-- FIX: '||' i.p.v. 'of' -->
        if (a.huisnummertoevoeging) parts.push(a.huisnummertoevoeging);
        const street = parts.join(' ');
        const city = [a.postcode, a.plaats].filter(Boolean).join(' ');
        return [street, city].filter(Boolean).join(', ');
      }

      for (const a of cand) {
        const s = fmt(a);
        if (s) return s;
      }
      return null;
    }

    // Plot helper
    async function plotFromBasisprofiel(bp, { usedGeo }) {
      let lon, lat;
      if (usedGeo) {
        const ll = findLatLonInBasisprofiel(bp);
        if (ll) { lon = ll.lon; lat = ll.lat; }
      }
      if (lon == null || lat == null) {
        const addr = addressFromBasisprofiel(bp);
        if (!addr) throw new Error('Geen (geoData of) adres gevonden in basisprofiel.');
        const g = await geocodePDOK(addr);
        lon = g.lon; lat = g.lat;
      }
      addMarker(lon, lat, bp.naam || bp.kvkNummer);
      return { lon, lat };
    }

    // --- UI refs ---
    const apiBaseEl = document.getElementById('apiBase');
    const apiKeyEl = document.getElementById('apiKey');
    const useGeoDataEl = document.getElementById('useGeoData');
    const kvkInputEl = document.getElementById('kvkInput');
    const btnGet = document.getElementById('btnGet');
    const resultsEl = document.getElementById('results');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');

    function showStatus(text) { statusEl.textContent = text || ''; }
    function showError(msg) {
      statusEl.textContent = '';
      const div = document.createElement('div');
      div.className = 'error section';
      div.textContent = msg;
      resultsEl.prepend(div);
    }

    // Rendering basisprofiel-kaartje
    function renderBasisprofielCard(bp, { plotted=false, error=null }) {
      const card = document.createElement('div');
      card.className = 'result stack';

      const title = document.createElement('h3');
      title.textContent = `${bp.naam || bp.statutaireNaam || '(naam onbekend)'} — ${bp.kvkNummer || ''}`;
      card.appendChild(title);

      const line = document.createElement('div');
      line.innerHTML = plotted
        ? `<span class="chip ok">Geplot ✓</span>`
        : error
          ? `<span class="chip warn" title="${String(error)}">Niet geplot ⚠</span>`
          : `<span class="chip info">Laden…</span>`;
      card.appendChild(line);

      const addr = addressFromBasisprofiel(bp);
      if (addr) {
        const addrDiv = document.createElement('div');
        addrDiv.className = 'muted';
        addrDiv.innerHTML = `<span class="badge">adres:</span> ${addr}`;
        card.appendChild(addrDiv);
      }

      resultsEl.appendChild(card);
      return card;
    }

    function updateChip(container, { text, add = [], remove = [] }) {
      const chip = container.querySelector('.chip');
      if (!chip) return;
      remove.forEach(c => chip.classList.remove(c));
      add.forEach(c => chip.classList.add(c));
      if (typeof text === 'string') chip.textContent = text;
    }

    // Render een lijst van zoekresultaten + auto-load & auto-plot
    async function renderZoekResultatenAuto(zoek, { base, apikey, usedGeo }) {
      resultsEl.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'section';
      const hdr = document.createElement('div');
      hdr.className = 'muted';
      hdr.textContent = `Zoekresultaten: ${zoek.totaal} gevonden — basisprofielen laden & plotten…`;
      wrap.appendChild(hdr);
      resultsEl.appendChild(wrap);

      const items = Array.isArray(zoek.resultaten) ? zoek.resultaten : [];
      if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'muted';
        empty.textContent = 'Geen resultaten.';
        wrap.appendChild(empty);
        return;
      }

      const promises = items.map(async (item) => {
        try {
          const bp = await kvkBasisprofiel({ base, apikey, kvkNummer: item.kvkNummer, geoData: usedGeo });
          const card = renderBasisprofielCard(bp, { plotted:false });
          await plotFromBasisprofiel(bp, { usedGeo });
          updateChip(card, { text: 'Geplot ✓', add: ['ok'], remove: ['info','warn'] });
          return { ok: true, bp };
        } catch (err) {
          const bpLite = { kvkNummer: item.kvkNummer, naam: item.naam };
          const card = renderBasisprofielCard(bpLite, { plotted:false, error: err.message || err });
          updateChip(card, { text: 'Niet geplot ⚠', add: ['warn'], remove: ['info','ok'] });
          return { ok: false, error: err };
        }
      });

      await Promise.allSettled(promises);
      hdr.textContent = `Zoekresultaten: ${zoek.totaal} gevonden — klaar.`;
      fitToFeatures();
    }

    // --- Event: zoeken / ophalen ---
    const btnHandler = async () => {
      vectorSource.clear();
      resultsEl.innerHTML = '';
      const base = apiBaseEl.value;
      const apikey = apiKeyEl.value.trim();
      const query = kvkInputEl.value.trim();
      const usedGeo = !!useGeoDataEl.checked;
      if (!query) { showError('Vul een KVK-nummer of (deel van) een naam in.'); return; }

      try {
        showStatus('Bezig…');

        if (/^\d{8}$/.test(query)) {
          // KVK-nummer → direct basisprofiel + plot
          const bp = await kvkBasisprofiel({ base, apikey, kvkNummer: query, geoData: usedGeo });
          resultsEl.innerHTML = '';
          const card = renderBasisprofielCard(bp, { plotted:false });
          await plotFromBasisprofiel(bp, { usedGeo });
          updateChip(card, { text: 'Geplot ✓', add: ['ok'], remove: ['info','warn'] });
          fitToFeatures();
          summaryEl.textContent = `Basisprofiel geladen (${bp.kvkNummer})`;
        } else {
          // Naam → zoeken, alles automatisch ophalen en plotten
          const zoek = await kvkZoekOpNaam({ base, apikey, naam: query, pagina: 1, resultatenPerPagina: 10 });
          await renderZoekResultatenAuto(zoek, { base, apikey, usedGeo });
          summaryEl.textContent = `Zoekopdracht uitgevoerd: “${query}” (alles geplot)`;
        }

        showStatus('');
      } catch (e) {
        const d = e.details;
        if (d) {
          showError(`Fout (${d.status} ${d.statusText})
URL: ${d.url}
Body: ${d.body?.slice(0,500) || '(leeg)'}
Tip: controleer API key / test endpoint / invoer.`);
        } else {
          showError(e.message || 'Onbekende fout');
        }
        showStatus('');
      }
    };

    btnGet.addEventListener('click', btnHandler);
    kvkInputEl.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') btnHandler(); });

    // Demo: prefill
    kvkInputEl.value = '69599068';
  </script>
</body>
</html>
